
## 目录
* [基础流程](#基础流程)
* [classMap](#classMap)
* [PSR4](#PSR4)
* [PSR0](#PSR0)
* [使用apcu扩展优化](#使用apcu扩展优化)

# 基础流程
Composer源码一般都在框架的入口处引入，用来注册一个类自动加载，以Yii2的入口文件为例
```
<?php
defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');
//引入Composer
require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

$config = require __DIR__ . '/../config/web.php';
(new yii\web\Application($config))->run();
```
Composer源码一般在框架的vendor文件夹下的composer中  
从autoload.php开始，这个文件返回了一个ClassLoader类的实例，这是一个单例模式  
```
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c::getLoader();
```
已PHP7+版本，没有HHVM支持来看源码  
```
public static function getLoader()
{
    //单例模式
    if (null !== self::$loader) {
        return self::$loader;
    }
    //注册类自动加载
    spl_autoload_register(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    //删除注册的类自动加载
    spl_autoload_unregister(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'));

    $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
    if ($useStaticLoader) {
        require_once __DIR__ . '/autoload_static.php';

        call_user_func(\Composer\Autoload\ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::getInitializer($loader));
    } else {
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }

        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace => $path) {
            $loader->setPsr4($namespace, $path);
        }

        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }
    }
    //注册类自动加载
    $loader->register(true);

    if ($useStaticLoader) {
        $includeFiles = Composer\Autoload\ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$files;
    } else {
        $includeFiles = require __DIR__ . '/autoload_files.php';
    }
    foreach ($includeFiles as $fileIdentifier => $file) {
        composerRequire97e0a3a5b1c8c48ec684b54219c87b9c($fileIdentifier, $file);
    }

    return $loader;
}
```
我对这里有一个疑问，如下
```
spl_autoload_register(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'), true, true);
self::$loader = $loader = new \Composer\Autoload\ClassLoader();
spl_autoload_unregister(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'));
```
这个类自动加载的作用主要是引入ClassLoader.php文件，为何不直接引入而要用自动加载引入？？？很费解
```
public static function loadClassLoader($class)
{
    if ('Composer\Autoload\ClassLoader' === $class) {
        require __DIR__ . '/ClassLoader.php';
    }
}
```
这个问题我提issue给官方，有兴趣的同学可以去看一下，我是没看懂啥意思，英文实在太差
https://github.com/composer/composer/issues/7684
因为ClassLoader的prefixLengthsPsr4、prefixDirsPsr4、prefixesPsr0、classMap属性都是私有的，需要从autoload_static这个文件中去赋值，composer使用了闭包绑定机制(我感觉代码很秀)
```
//将autoload_static的几个属性赋值给ClassLoader的私有属性
public static function getInitializer(ClassLoader $loader)
{
    return \Closure::bind(function () use ($loader) {
        $loader->prefixLengthsPsr4 = ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$prefixLengthsPsr4;
        $loader->prefixDirsPsr4 = ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$prefixDirsPsr4;
        $loader->prefixesPsr0 = ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$prefixesPsr0;
        $loader->classMap = ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$classMap;

    }, null, ClassLoader::class);
}
```
然后就是注册一个类自动加载，并且将这个自动加载放到加载队列的最前面
```
public function register($prepend = false)
{
    spl_autoload_register(array($this, 'loadClass'), true, $prepend);
}
public function loadClass($class)
{
    if ($file = $this->findFile($class)) {
        includeFile($file);

        return true;
    }
}
```
在findFile方法中，涉及到classMap、PSR4、PSR0三种类查找模式
# classMap
classMap模式是最直观的，直接查找类与真实文件路径的映射关系
```
if (isset($this->classMap[$class])) {
    return $this->classMap[$class];
}
//如果classMap查不到的话，或者以前的查找找不到的话，是否直接返回false
if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
    return false;
}
```
classMap的缺点就是需要维护的映射关系太大，Yii2的默认classMap有600多行之多  
也可以手动添加classMap，使用addClassMap方法
```
public function addClassMap(array $classMap)
{
    if ($this->classMap) {
        $this->classMap = array_merge($this->classMap, $classMap);
    } else {
        $this->classMap = $classMap;
    }
}
```
获取classMap方法如下
```
public function getClassMap()
{
    return $this->classMap;
}
```
# PSR4
如果classMap查找模式找不到的话，会去使用PSR4模式
```
private function findFileWithExtension($class, $ext)
{
    // PSR-4 lookup
    $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
    $first = $class[0];
    if (isset($this->prefixLengthsPsr4[$first])) {
        $subPath = $class;
        while (false !== $lastPos = strrpos($subPath, '\\')) {
            $subPath = substr($subPath, 0, $lastPos);
            $search = $subPath . '\\';
            if (isset($this->prefixDirsPsr4[$search])) {
                $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                foreach ($this->prefixDirsPsr4[$search] as $dir) {
                    if (file_exists($file = $dir . $pathEnd)) {
                        return $file;
                    }
                }
            }
        }
    }

    // PSR-4 fallback dirs
    foreach ($this->fallbackDirsPsr4 as $dir) {
        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
            return $file;
        }
    }
    ....
}
```
代码不多但是逻辑比较绕，总体来说就是如下:  
如果要找a\b\c\obj这个类  
- 变成a\b\c\obj.php
- 获取第一个字符，为a，判断prefixLengthsPsr4属性是否存在键为a的
- 获取a\b\c\，判断prefixDirsPsr4属性是否存在a\b\c\
- 如果prefixDirsPsr4设置为如下，则会找__DIR__ . '/../my/test/obj.php'是否存在，不存在则会找__DIR__.'/../XXX/obj.php'是否存在
```
public prefixDirsPsr4 = [
    "a\\b\\c\\" => [
        0 => __DIR__ . '/..' . '/my/test',
        1 => __DIR__ . '/..' . '/xxx',
    ],
    "a\\b\\" => [
        0 => __DIR__ . '/..' . '/ok',
        1 => __DIR__ . '/..' . '/notok',
    ],
];
```
- 如果找不到的话会获取a\b,然后会找__DIR__.'/../ok/c/obj.php'
