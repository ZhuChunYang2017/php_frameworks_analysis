
## 目录
* [基础流程](#基础流程)
* [classMap](#classMap)
* [PSR4](#PSR4)
* [PSR0](#PSR0)

# 基础流程
Composer源码一般都在框架的入口处引入，用来注册一个类自动加载，以Yii2的入口文件为例
```
<?php
defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');
//引入Composer
require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

$config = require __DIR__ . '/../config/web.php';
(new yii\web\Application($config))->run();
```
Composer源码一般在框架的vendor文件夹下的composer中  
从autoload.php开始，这个文件返回了一个ClassLoader类的实例，这是一个单例模式  
```
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c::getLoader();
```
已PHP7+版本，没有HHVM支持来看源码  
```
public static function getLoader()
{
    //单例模式
    if (null !== self::$loader) {
        return self::$loader;
    }
    //注册类自动加载
    spl_autoload_register(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    //删除注册的类自动加载
    spl_autoload_unregister(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'));

    $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
    if ($useStaticLoader) {
        require_once __DIR__ . '/autoload_static.php';

        call_user_func(\Composer\Autoload\ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::getInitializer($loader));
    } else {
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }

        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace => $path) {
            $loader->setPsr4($namespace, $path);
        }

        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }
    }
    //注册类自动加载
    $loader->register(true);

    if ($useStaticLoader) {
        $includeFiles = Composer\Autoload\ComposerStaticInit97e0a3a5b1c8c48ec684b54219c87b9c::$files;
    } else {
        $includeFiles = require __DIR__ . '/autoload_files.php';
    }
    foreach ($includeFiles as $fileIdentifier => $file) {
        composerRequire97e0a3a5b1c8c48ec684b54219c87b9c($fileIdentifier, $file);
    }

    return $loader;
}
```
我对这里有一个疑问，如下
```
spl_autoload_register(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'), true, true);
self::$loader = $loader = new \Composer\Autoload\ClassLoader();
spl_autoload_unregister(array('ComposerAutoloaderInit97e0a3a5b1c8c48ec684b54219c87b9c', 'loadClassLoader'));
```
这个类自动加载的作用主要是引入ClassLoader.php文件，为何不直接引入而要用自动加载引入？？？很费解
```
public static function loadClassLoader($class)
{
    if ('Composer\Autoload\ClassLoader' === $class) {
        require __DIR__ . '/ClassLoader.php';
    }
}
```
这个问题我提issue给官方，有兴趣的同学可以去看一下，我是没看懂啥意思，英文实在太差
https://github.com/composer/composer/issues/7684
