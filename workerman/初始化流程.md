使用的wm版本为3.5.22  

## 目录
* [初始化](#初始化)
* [源码分析](#源码分析)

# 初始化
在执行构造方法时候，初始化了两个关键的静态属性_workers和_pidMap，使用spl_object_hash对本对象进行唯一性hash，然后将hash结果存入_workers和_pidMap  
如果需要监听端口，还进行了backlog设置，默认是102400
```
public function __construct($socket_name = '', $context_option = array())
{
    // Save all worker instances.
    $this->workerId                    = \spl_object_hash($this);
    static::$_workers[$this->workerId] = $this;
    static::$_pidMap[$this->workerId]  = array();

    // Get autoload root path.
    $backtrace                = \debug_backtrace();
    $this->_autoloadRootPath = \dirname($backtrace[0]['file']);

    if (static::$_OS === OS_TYPE_LINUX && version_compare(PHP_VERSION,'7.0.0', 'ge')) {
        $php_uname = strtolower(php_uname('s'));
        // If not Mac OS then turn reusePort on.
        if ($php_uname !== 'darwin') {
            $this->reusePort = true;
        }
    }

    // Context for socket.
    if ($socket_name) {
        $this->_socketName = $socket_name;
        $this->parseSocketAddress();
        if (!isset($context_option['socket']['backlog'])) {
            $context_option['socket']['backlog'] = static::DEFAULT_BACKLOG;
        }
        $this->_context = \stream_context_create($context_option);
    }
}
```
根据需要监听的协议类型，选择一个类进行输出和输入的解析，选择类的逻辑如下
```
protected function parseSocketAddress() {
    if (!$this->_socketName) {
        return;
    }
    // Get the application layer communication protocol and listening address.
    list($scheme, $address) = \explode(':', $this->_socketName, 2);
    // Check application layer protocol class.
    if (!isset(static::$_builtinTransports[$scheme])) {
        $scheme         = \ucfirst($scheme);
        $this->protocol = \substr($scheme,0,1)==='\\' ? $scheme : '\\Protocols\\' . $scheme;
        if (!\class_exists($this->protocol)) {
            $this->protocol = "\\Workerman\\Protocols\\$scheme";
            if (!\class_exists($this->protocol)) {
                throw new Exception("class \\Protocols\\$scheme not exist");
            }
        }

        if (!isset(static::$_builtinTransports[$this->transport])) {
            throw new \Exception('Bad worker->transport ' . \var_export($this->transport, true));
        }
    } else {
        $this->transport = $scheme;
    }

    $local_socket = static::$_builtinTransports[$this->transport] . ":" . $address;
    return $local_socket;
}
```
如果需要监听的是http协议，其实会转换成监听tcp的协议
